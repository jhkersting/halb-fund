# Import data (simulated data for this example)
myData<- read.csv('/Users/kyelee/Dropbox/Jupyter/Shin/df_apr2022.csv')
myData<- read.csv('/Users/kyelee/Dropbox/Jupyter/Shin/df_apr2022.csv')
random <- plm( expenditure_recuperation ~ pct_enroll, data=myData, model="random")
summary(random)
library(plm)
install plm
install.packages("plm")
library(plm)
random <- plm( expenditure_recuperation ~ pct_enroll, data=myData, model="random")
summary(random)
random <- plm(expenditure_recuperation ~ pct_enroll, data=myData, model="random")
random <- plm(st_admission~ pct_enroll, data=myData, model="random")
summary(random)
random <- plm(st_admission~skill_mix_RN_CW , data=myData, model="random")
summary(random)
random <- plm(st_admission~skill_mix_RN_CW , data=myData, model="random")
#summary(random)
random <- plm(st_medication~skill_mix_RN_CW , data=myData, model="random")
#summary(random)
random <- plm(st_medication~RN HPRD , data=myData, model="random")
#summary(random)
View(myData)
View(myData)
random <- plm(st_medication~RN.HPRD , data=myData, model="random")
#summary(random)
df <- data.frame(a=rnorm(5), b=rnorm(5), c=rnorm(5), d=rnorm(5), e=rnorm(5))
View(df)
View(df)
df[, c("a", "c", "e")]
df
df <- data.frame(
v1 = c(1,3,5,7,8,3,5,NA,4,5,7,9),
v2 = c(11,33,55,77,88,33,55,NA,44,55,77,99),
by1 = c("red", "blue", 1, 2, NA, "big", 1, 2, "red", 1, NA, 12),
by2 = c("wet", "dry", 99, 95, NA, "damp", 95, 99, "red", 99, NA, NA))
df
s=0:4
s
s %in% c(2,4)
s %in% c(2:4)
df <- data.frame(a=rnorm(10), b=rnorm(10))
df
subset(df, a <= b)
df[df$a <= df$b,]
df$a
df[a]
df[df$a]
df[df$a]
s=0:4
s %in% c(2:4)
df$a.T
[df$a]
df[,c("a"")]
subset(df, a <= b)
df[df$a <= df$b,]
df[,c("a"")]
df[,c("a")]
df
for (val in 1: 5)
{
# statement
print(val)
}
val = 1
# using while loop
while (val <= 5)
{
# statements
print(val)
val = val + 1
}
# using while loop
while (val != NA)
{
# statements
print(val)
val = val + 1
}
val = 1
# using while loop
while (val != 0)
{
# statements
print(val)
val = val + 1
}
# using while loop
while (val <10)
{
# statements
print(val)
val = val + 1
}
n < - 5
n
n <- 5
n
# install.packages("fixest")
install.packages('dplyr')
# install.packages("fixest")
install.packages('fixest')
# install.packages("fixest")
install.packages('lfe')
# 5.1 Valuation Option Boundaries Test.R
# rmarkdown::render("5.1 Valuation Option Boundaries Test.R",
#  "word_document")
rm(list = ls())  # Take out the Environment "trash"
cat("\014") # Clear Console, making error checking easier.
while (!is.null(dev.list()))  dev.off() # Clear old plots
#par(family = 'Times New Roman') # Globally set fonts for graphs
# Libraries
Packages <- c("data.table", "date", "stats", "tis", "gtools", "openxlsx")
if(length(setdiff(Packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(Packages, rownames(installed.packages())))
} # Make sure libraries are installed on this computer
lapply(Packages, library, character.only=TRUE) # Load and attach libraries
rm(Packages)
# Plots to produce
CallLB <- TRUE
CallTV <- FALSE
PutLB <- TRUE
PutTV <- FALSE
# 5.1 Valuation Option Boundaries Test.R
# rmarkdown::render("5.1 Valuation Option Boundaries Test.R",
#  "word_document")
rm(list = ls())  # Take out the Environment "trash"
cat("\014") # Clear Console, making error checking easier.
while (!is.null(dev.list()))  dev.off() # Clear old plots
#par(family = 'Times New Roman') # Globally set fonts for graphs
# Libraries
Packages <- c("data.table", "date", "stats", "tis", "gtools", "openxlsx")
if(length(setdiff(Packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(Packages, rownames(installed.packages())))
} # Make sure libraries are installed on this computer
lapply(Packages, library, character.only=TRUE) # Load and attach libraries
rm(Packages)
# Plots to produce
CallLB <- TRUE
CallTV <- FALSE
PutLB <- TRUE
PutTV <- FALSE
# Fix call axis for lower bounds and time values
FixXRangeCLB <- TRUE
FixYRangeCLB <- TRUE
MinXRangeCLB <- 75
MaxXRangeCLB <- 125
MinYRangeCLB <- 0
MaxYRangeCLB <- 30
FixXRangeCTV <- TRUE
FixYRangeCTV <- TRUE
MinXRangeCTV <- 75
MaxXRangeCTV <- 125
MinYRangeCTV <- 0
MaxYRangeCTV <- 15
# Fix put axis for lower bounds and time values
FixXRangePLB <- TRUE
FixYRangePLB <- TRUE
MinXRangePLB <- 75
MaxXRangePLB <- 125
MinYRangePLB <- 0
MaxYRangePLB <- 30
FixXRangePTV <- TRUE
FixYRangePTV <- TRUE
MinXRangePTV <- 75
MaxXRangePTV <- 125
MinYRangePTV <- 0
MaxYRangePTV <- 15
# Put-call parity range
FixXRangePCP <- TRUE
FixYRangePCP <- TRUE
MinXRangePCP <- 75
MaxXRangePCP <- 125
MinYRangePCP <- 0
MaxYRangePCP <- 30
#
# Analysis of half year options
#
# Analysis of call lower bound
FileName = "SPYHalf20051215.xlsx"
source('Call Lower Bound.R')
setwd("~/Dropbox/Apps/Rakuten Kobo/FI520_2023_Kyle/QFRepository/Ch 5 Valuation Options/5.1 Valuation Option Boundaries/5.1 Valuation Option Boundaries")
#
# Analysis of half year options
#
# Analysis of call lower bound
FileName = "SPYHalf20051215.xlsx"
source('Call Lower Bound.R')
FileName = "SPYHalf20081215.xlsx"
source('Call Lower Bound.R')
FileName = "SPYHalf20111215.xlsx"
source('Call Lower Bound.R')
# Analysis of put lower bound
FileName = "SPYHalf20051215.xlsx"
source('Put Lower Bound.R')
FileName = "SPYHalf20081215.xlsx"
source('Put Lower Bound.R')
FileName = "SPYHalf20111215.xlsx"
source('Put Lower Bound.R')
# Analysis of put call parity bounds
FileName = "SPYHalf20051215.xlsx"
source('Put Call Parity.R')
FileName = "SPYHalf20081215.xlsx"
source('Put Call Parity.R')
FileName = "SPYHalf20111215.xlsx"
source('Put Call Parity.R')
#
# Analysis of quarter year options
#
# Analysis of call lower bound
FileName = "SPYQuarter20051215.xlsx"
source('Call Lower Bound.R')
FileName = "SPYQuarter20081215.xlsx"
source('Call Lower Bound.R')
FileName = "SPYQuarter20111215.xlsx"
source('Call Lower Bound.R')
# Analysis of put lower bound
FileName = "SPYQuarter20051215.xlsx"
# Valuation GBM Binomial OVM European-Style Normalized Test.R
# Geometric Brownian Motion
# Illustrating European-style binomial option valuation and related functions in R
# rmarkdown::render("Valuation GBM Binomial OVM European-Style Test.R", "word_document")
rm(list = ls())  # Take out the Environment "trash"
cat("\014") # Clear Console, making error checking easier.
while (!is.null(dev.list()))  dev.off() # Clear old plots
par(family = 'Times New Roman') # Globally set fonts for graphs
PackagesToLibrary <- c("beepr") # Libraries
if (length(setdiff(PackagesToLibrary, rownames(installed.packages()))) > 0) {
install.packages(setdiff(PackagesToLibrary, rownames(installed.packages())))
} # Make sure libraries are installed on this computer
lapply(PackagesToLibrary,library,character.only = TRUE) # Load and attach libraries
rm(PackagesToLibrary)
source('ESGBMBINOVM Functions.R')
setwd("~/Dropbox/Apps/Rakuten Kobo/FI520_2023_Kyle/QFRepository/Ch 5 Valuation Options/5.2 Valuation GBM Binomial OVM")
source('ESGBMBINOVM Functions.R')
# Test inputs
inputStockPrice = 100.0          # Need "input" as using variable names below
inputStrikePrice = 100.0         # In currency units, numeric
inputInterestRate = 0.62          # In percent
inputDividendYield = 3.14         # In percent
inputVolatility = 30.0           # In percent
inputTimeToMaturity = 197/365        # In fraction of year
inputType = 1L                   # 1 for call, -1 for put
source('ESGBMBINOVM Functions.R')
# Test inputs
inputStockPrice = 100.0          # Need "input" as using variable names below
inputStrikePrice = 100.0         # In currency units, numeric
inputInterestRate = 0.62          # In percent
inputDividendYield = 3.14         # In percent
inputVolatility = 30.0           # In percent
inputTimeToMaturity = 197/365        # In fraction of year
inputType = 1L                   # 1 for call, -1 for put
inputNumberOfSteps = as.integer(500)   # Or use L: 1000L
inputPayoutType = 1L             # 1 Plain vanilla, 2 digital
inputEMMProbability = 50.0       # In percent
inputDigitalPayout = 100.0
LowerBoundX = 75 # Analysis wrt strike price
UpperBoundX = 125
NumberOfObservations = 101
StepSize = 1L # Analysis wrt number of steps
MinStep = 5L # Must be multiple of StepSize
MaxStep = 500L # Must be multiple of StepSize
# Plot footers
TS = paste0('S=', inputStockPrice)
# TX = paste0(',X=', inputStrikePrice)
TR = paste0(',r=', inputInterestRate)
Td = paste0(',d=', inputDividendYield, ',')
TV = paste0('Vol=', inputVolatility)
TT = paste0(',T=',inputTimeToMaturity)
TN = paste0(',N=',inputNumberOfSteps)
TDP = paste0(',DP=', inputDigitalPayout)
sTitleBIN = paste0(TS, TR, Td, TV, TT, TN)
sTitleBINDP = paste0(TS, TR, Td, TV, TT, TN, TDP)
#  ESBINInputData - list of inputs with associated names
ESBINInputData <- list(inputStockPrice, inputStrikePrice, inputInterestRate,
inputDividendYield, inputVolatility, inputTimeToMaturity, inputType,
inputNumberOfSteps, inputPayoutType, inputEMMProbability,
inputDigitalPayout)
names(ESBINInputData) <- c("StockPrice", "StrikePrice", "InterestRate",
"DividendYield", "Volatility", "TimeToMaturity", "Type", "NumberOfSteps",
"PayoutType", "EMMProbability", "DigitalPayout")
is.integer(ESBINInputData$Type)
ESBINInputData
ESBINInputData$Type = 1L
ESBINInputData$PayoutType = 1L
PVCallLB = ESBINOptionLowerBound(ESBINInputData)
PVCallLB
PVCallUB = ESBINOptionUpperBound(ESBINInputData)
# Test inputs
inputStockPrice = 100.0          # Need "input" as using variable names below
inputStrikePrice = 100.0         # In currency units, numeric
inputInterestRate = 0.62          # In percent
inputDividendYield = 3.14         # In percent
inputVolatility = 30.0           # In percent
inputTimeToMaturity = 197/365        # In fraction of year
inputType = 1L                   # 1 for call, -1 for put
inputNumberOfSteps = as.integer(500)   # Or use L: 1000L
inputPayoutType = 1L             # 1 Plain vanilla, 2 digital
inputEMMProbability = 50.0       # In percent
inputDigitalPayout = 100.0
LowerBoundX = 75 # Analysis wrt strike price
UpperBoundX = 125
NumberOfObservations = 101
StepSize = 1L # Analysis wrt number of steps
MinStep = 5L # Must be multiple of StepSize
MaxStep = 500L # Must be multiple of StepSize
# Plot footers
TS = paste0('S=', inputStockPrice)
# TX = paste0(',X=', inputStrikePrice)
TR = paste0(',r=', inputInterestRate)
Td = paste0(',d=', inputDividendYield, ',')
TV = paste0('Vol=', inputVolatility)
TT = paste0(',T=',inputTimeToMaturity)
TN = paste0(',N=',inputNumberOfSteps)
TDP = paste0(',DP=', inputDigitalPayout)
sTitleBIN = paste0(TS, TR, Td, TV, TT, TN)
sTitleBINDP = paste0(TS, TR, Td, TV, TT, TN, TDP)
#  ESBINInputData - list of inputs with associated names
ESBINInputData <- list(inputStockPrice, inputStrikePrice, inputInterestRate,
inputDividendYield, inputVolatility, inputTimeToMaturity, inputType,
inputNumberOfSteps, inputPayoutType, inputEMMProbability,
inputDigitalPayout)
names(ESBINInputData) <- c("StockPrice", "StrikePrice", "InterestRate",
"DividendYield", "Volatility", "TimeToMaturity", "Type", "NumberOfSteps",
"PayoutType", "EMMProbability", "DigitalPayout")
is.integer(ESBINInputData$Type)
ESBINInputData
ESBINInputData$Type = 1L
ESBINInputData$PayoutType = 1L
PVCallLB = ESBINOptionLowerBound(ESBINInputData)
PVCallLB
PVCallUB = ESBINOptionUpperBound(ESBINInputData)
PVCallUB
PVCallValue = ESBINOptionValue(ESBINInputData)
PVCallValue
ESBINInputData$Type = -1L
PVPutLB = ESBINOptionLowerBound(ESBINInputData)
PVPutLB
PVPutUB = ESBINOptionUpperBound(ESBINInputData)
PVPutUB
PVPutValue = ESBINOptionValue(ESBINInputData)
PVPutValue
ESBINInputData$PayoutType = 2L
ESBINInputData$Type = 1L
DigitalCallValue = ESBINOptionValue(ESBINInputData)
DigitalCallValue
ESBINInputData$PayoutType = 2L
ESBINInputData$Type = -1L
DigitalPutValue = ESBINOptionValue(ESBINInputData)
DigitalPutValue
PV = exp(-(inputInterestRate/100.0)*inputTimeToMaturity)*inputDigitalPayout
PV
DV = DigitalCallValue + DigitalPutValue
DV
Diff = PV - DV
Diff
# Normalized Strike Price
StepSizeX = (UpperBoundX - LowerBoundX)/(NumberOfObservations - 1)
StrikePrice <- c(1:NumberOfObservations)
NStrikePrice <- c(1:NumberOfObservations)
PVCallLB <- c(1:NumberOfObservations)
PVCallUB <- c(1:NumberOfObservations)
PVCallValue <- c(1:NumberOfObservations)
PVPutLB <- c(1:NumberOfObservations)
PVPutUB <- c(1:NumberOfObservations)
PVPutValue <- c(1:NumberOfObservations)
for(i in 1:NumberOfObservations){
StrikePrice[i] <- LowerBoundX + (i - 1)*StepSizeX
NStrikePrice[i] <- (StrikePrice[i]/inputStockPrice)*100
ESBINInputData$StrikePrice = StrikePrice[i]
ESBINInputData$Type = 1L
ESBINInputData$PayoutType = 1L
PVCallLB[i] = (ESBINOptionLowerBound(ESBINInputData)/inputStockPrice)*100
PVCallUB[i] = (ESBINOptionUpperBound(ESBINInputData)/inputStockPrice)*100
PVCallValue[i] = (ESBINOptionValue(ESBINInputData)/inputStockPrice)*100
ESBINInputData$Type = -1L
PVPutLB[i] = (ESBINOptionLowerBound(ESBINInputData)/inputStockPrice)*100
PVPutUB[i] = (ESBINOptionUpperBound(ESBINInputData)/inputStockPrice)*100
PVPutValue[i] = (ESBINOptionValue(ESBINInputData)/inputStockPrice)*100
}
ESBINInputData$StrikePrice = inputStrikePrice # Reset from previous analysis
# Plots: Plain Vanilla Options with respect to the Stock Price
MaxValue = max(NStrikePrice); MinValue = min(NStrikePrice)
xlim1 = c(1:2); xlim1[1] = MinValue; xlim1[2] = MaxValue
#  Call with boundaries
MaxValue = max(PVCallValue, PVCallLB, PVCallUB)
MinValue = min(PVCallValue, PVCallLB, PVCallUB)
ylim1 = c(1:2); ylim1[1] = MinValue; ylim1[2] = MaxValue
legtxt = c("Call Value", "Call Lower Bound", "Call Upper Bound")
mTitle = "Normalized ES Binomial Call Option Value (GBM)"
xTitle = "Strike Price/Stock Price (%)"
yTitle = "Call Value/Stock Price (%)"
lTitle = "Parameter"
plot(NStrikePrice, PVCallValue, type = "b", main = mTitle,
sub = sTitleBIN, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
lines(NStrikePrice, PVCallLB, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 2, cex = 0.5)
lines(NStrikePrice, PVCallUB, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 3, cex = 0.5)
legend("right", legtxt, cex = 0.75, lwd = c(1, 1, 1), lty = c(1, 1, 1),
col = c("black", "black", "black"), pch = c(1,2,3), bty = "n",
title = lTitle)
#  Call time value
PVCallTV <- PVCallValue - PVCallLB
MaxValue = max(PVCallTV)
MinValue = min(PVCallTV)
ylim1 = c(1:2); ylim1[1] = MinValue; ylim1[2] = MaxValue
mTitle = "Normalized ES Binomial Call Option Time Value (GBM)"
xTitle = "Strike Price/Stock Price (%)"
yTitle = "Call Time Value/Stock Price (%)"
lTitle = "Parameter"
plot(NStrikePrice, PVCallTV, type = "b", main = mTitle,
sub = sTitleBIN, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
# Put with boundaries
MaxValue = max(PVPutValue, PVPutLB, PVPutUB)
MinValue = min(PVPutValue, PVPutLB, PVPutUB)
ylim1 = c(1:2); ylim1[1] = MinValue; ylim1[2] = MaxValue
legtxt = c("Put Value", "Put Lower Bound", "Put Upper Bound")
mTitle = "Normalized ES Binomial Put Option Time Value (GBM)"
xTitle = "Strike Price/Stock Price (%)"
yTitle = "Put Time Value/Stock Price (%)"
lTitle = "Parameter"
plot(NStrikePrice, PVPutValue, type = "b", main = mTitle,
sub = sTitleBIN, xlab = xTitle, ylab = yTitle, col = "black", xlim = xlim1,
ylim = ylim1, pch = 1, cex = 0.5)
lines(NStrikePrice, PVPutLB, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 2, cex = 0.5)
lines(NStrikePrice, PVPutUB, type = "b", col ="black", xlim = xlim1,
ylim = ylim1, pch = 3, cex = 0.5)
legend("topleft", legtxt, cex = 0.75, lwd = c(1, 1, 1), lty = c(1, 1, 1),
col = c("black", "black", "black"), pch = c(1,2,3), bty = "n",
title = lTitle)
